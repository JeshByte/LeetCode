The constraints allow a n^2 solution so we can go through all the possible pair combinations of edges to find the optimal answer. As this is a tree, cutting an edge will increase one component and thus cutting 2 edges will always result in total 3 components. So we have to check for all the edges. We will use 2 nested dfs here with each dfs representing a cut. Each dfs call dfs(x) will return the xor of all the nodes rooted at x(including x) and will represent the cut between x's parent and x. So first we will calculate the xor of all nodes rooted in x. Then we will do another dfs call from its parent which will go upwards. This dfs2 will now explore all the other possible second cuts(excluding the one we just made) and will similarly return the xor value of all nodes rooted at x. So after we got these two values the xor of the third component will be total^xor1^xor2 where total is the xor of all the nodes(which we will precompute). This formula can proven using xor property. Then using this in every dfs2 call we would find the score for the concerned two cuts we have made and minimise our final answer wherever possible.  
